name: Create Release Pipeline

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Select service to deploy'
        required: true
        type: choice
        options:
          - backend
          - frontend
        default: 'backend'
      release_branch:
        description: 'Release branch for rollback (e.g.
          releases/production/frontend-3.1.5). Leave empty for normal release
          from main'
        required: false
        type: string
        default: ''

env:
  HELM_VERSION: 'v3.13.0'

jobs:
  # ============================================
  # DETECTION & PREPARATION
  # ============================================

  detect-release-mode:
    name: Detect release mode
    runs-on: ubuntu-latest
    outputs:
      is_rollback: ${{ steps.detect.outputs.is_rollback }}
      rollback_version: ${{ steps.detect.outputs.rollback_version }}
      source_branch: ${{ steps.detect.outputs.source_branch }}
    steps:
      - name: Detect release mode
        id: detect
        run: |
          RELEASE_BRANCH="${{ github.event.inputs.release_branch }}"
          SERVICE_NAME="${{ github.event.inputs.service }}"

          if [ -n "$RELEASE_BRANCH" ]; then
            echo "Rollback mode detected"
            echo "is_rollback=true" >> $GITHUB_OUTPUT
            
            VERSION=$(echo "$RELEASE_BRANCH" | sed -E "s|releases/production/${SERVICE_NAME}-([0-9]+\.[0-9]+\.[0-9]+)|\1|")
            
            if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "Error: Could not extract valid version from branch $RELEASE_BRANCH"
              echo "Expected format: releases/production/${SERVICE_NAME}-X.Y.Z"
              exit 1
            fi
            
            echo "Rollback version: $VERSION"
            echo "rollback_version=$VERSION" >> $GITHUB_OUTPUT
            echo "source_branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
          else
            echo "Normal release mode from main"
            echo "is_rollback=false" >> $GITHUB_OUTPUT
            echo "rollback_version=" >> $GITHUB_OUTPUT
            echo "source_branch=main" >> $GITHUB_OUTPUT
          fi

  prepare-services:
    name: Prepare services list
    needs: detect-release-mode
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set-services.outputs.services }}
      service-type: ${{ steps.set-services.outputs.service-type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-release-mode.outputs.source_branch }}

      - name: Set services list
        id: set-services
        run: |
          SELECTED_SERVICE="${{ github.event.inputs.service }}"

          if ! command -v yq &> /dev/null; then
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi

          IS_NEST=$(yq eval ".services.nest[] | select(.name == \"$SELECTED_SERVICE\") | .name" services.yaml)
          IS_NEXT=$(yq eval ".services.next[] | select(.name == \"$SELECTED_SERVICE\") | .name" services.yaml)

          if [ -n "$IS_NEST" ]; then
            SERVICE_TYPE="nest"
          elif [ -n "$IS_NEXT" ]; then
            SERVICE_TYPE="next"
          else
            echo "Error: Service $SELECTED_SERVICE not found in services.yaml"
            exit 1
          fi

          SERVICES_JSON=$(echo "$SELECTED_SERVICE" | jq -R -c '[.]')

          echo "Selected service: $SELECTED_SERVICE"
          echo "Service type: $SERVICE_TYPE"
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "service-type=$SERVICE_TYPE" >> $GITHUB_OUTPUT

  # ============================================
  # ROLLBACK FLOW
  # ============================================

  validate-rollback:
    name: Validate rollback for ${{ matrix.service-name }}
    needs: [ detect-release-mode, prepare-services ]
    if: needs.detect-release-mode.outputs.is_rollback == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-release-mode.outputs.source_branch }}
          fetch-depth: 0

      - name: Validate rollback branch exists
        run: |
          BRANCH="${{ needs.detect-release-mode.outputs.source_branch }}"
          if ! git rev-parse --verify "origin/$BRANCH" >/dev/null 2>&1; then
            echo "Error: Branch $BRANCH does not exist"
            exit 1
          fi
          echo "Branch $BRANCH exists and is valid"

      - name: Check Docker image exists
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          VERSION: ${{ needs.detect-release-mode.outputs.rollback_version }}
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
        run: |
          IMAGE_TAG="production-${SERVICE_NAME}-v${VERSION}"
          echo "Checking if Docker image exists: $DOCKER_HUB_USERNAME/supreme:$IMAGE_TAG"

          TOKEN=$(curl -s "https://hub.docker.com/v2/users/login/" \
            -H "Content-Type: application/json" \
            -d '{"username": "'"$DOCKER_HUB_USERNAME"'", "password": "'"$DOCKER_HUB_TOKEN"'"}' | jq -r .token)

          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://hub.docker.com/v2/repositories/$DOCKER_HUB_USERNAME/supreme/tags/$IMAGE_TAG" \
            -H "Authorization: Bearer $TOKEN")

          if [ "$RESPONSE" != "200" ]; then
            echo "Error: Docker image $DOCKER_HUB_USERNAME/supreme:$IMAGE_TAG not found!"
            exit 1
          fi

          echo "Docker image found: $DOCKER_HUB_USERNAME/supreme:$IMAGE_TAG"

  rebase-rollback-branch:
    name: Rebase rollback branch onto main
    needs: [ detect-release-mode, prepare-services, validate-rollback ]
    if: needs.detect-release-mode.outputs.is_rollback == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.email "246592117+madara-robot@users.noreply.github.com"
          git config --global user.name "madara-robot"

      - name: Rebase rollback branch onto main
        env:
          BRANCH: ${{ needs.detect-release-mode.outputs.source_branch }}
        run: |
          git fetch origin "$BRANCH"
          git checkout "$BRANCH"
          echo "Rebasing $BRANCH onto main..."
          git rebase origin/main
          git push origin "$BRANCH" --force
          echo "Successfully rebased $BRANCH onto main"

  create-rollback-release:
    name: Create rollback GitHub release
    needs:
      [
        detect-release-mode,
        prepare-services,
        validate-rollback,
        rebase-rollback-branch
      ]
    if: needs.detect-release-mode.outputs.is_rollback == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-release-mode.outputs.source_branch }}

      - name: Install GitHub CLI
        uses: ./.github/workflows/jobs/install-github-cli

      - name: Create rollback release
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          VERSION: ${{ needs.detect-release-mode.outputs.rollback_version }}
          SOURCE_BRANCH: ${{ needs.detect-release-mode.outputs.source_branch }}
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          COMMIT_SHA=$(git rev-parse HEAD)
          SHORT_SHA=$(git rev-parse --short HEAD)
          TAG_NAME="${SERVICE_NAME}-rollback-v${VERSION}-${SHORT_SHA}"
          RELEASE_NAME="Rollback ${SERVICE_NAME} to v${VERSION}"

          cat > release_body.txt << EOF
          # $RELEASE_NAME

          ## Rollback Details
          - **Target Version:** v${VERSION}
          - **Commit:** \`${COMMIT_SHA}\`
          - **Source Branch:** ${SOURCE_BRANCH}

          ## Docker Image
          \`$DOCKER_HUB_USERNAME/supreme:production-${SERVICE_NAME}-v${VERSION}\`
          EOF

          if gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release $TAG_NAME already exists, skipping creation"
            exit 0
          fi

          echo "Creating rollback release $TAG_NAME"
          gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --notes-file release_body.txt \
            --repo "$GITHUB_REPOSITORY" \
            --target "$COMMIT_SHA"

  deploy-rollback-canary:
    name: Deploy rollback canary for ${{ matrix.service-name }}
    needs: [ detect-release-mode, prepare-services, create-rollback-release ]
    if: needs.detect-release-mode.outputs.is_rollback == 'true'
    runs-on: ubuntu-latest
    environment: canary
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-release-mode.outputs.source_branch }}

      - name: Setup Yandex Cloud
        uses: ./.github/workflows/jobs/setup-yandex-cloud
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
          yc-cloud-id: ${{ secrets.YC_CLOUD_ID }}
          yc-folder-id: ${{ secrets.YC_FOLDER_ID }}
          yc-k8s-cluster-id: ${{ secrets.YC_K8S_CLUSTER_ID }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Get current replica count
        id: get-replicas
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          CURRENT_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "2")
          CANARY_REPLICAS=$(( (CURRENT_REPLICAS + 1) / 2 ))
          [ "$CANARY_REPLICAS" -lt 1 ] && CANARY_REPLICAS=1
          echo "Current replicas: $CURRENT_REPLICAS, Canary replicas (50%): $CANARY_REPLICAS"
          echo "canary_replicas=$CANARY_REPLICAS" >> $GITHUB_OUTPUT

      - name: Deploy canary with Helm
        uses: ./.github/workflows/jobs/deploy-helm
        with:
          service-name: ${{ matrix.service-name }}
          service-type: ${{ needs.prepare-services.outputs.service-type }}
          version: ${{ needs.detect-release-mode.outputs.rollback_version }}
          docker-hub-username: ${{ secrets.DOCKER_HUB_USERNAME }}
          canary-enabled: 'true'
          canary-replicas: ${{ steps.get-replicas.outputs.canary_replicas }}

  approve-rollback-canary:
    name: Approve rollback canary promotion
    needs: [ detect-release-mode, prepare-services, deploy-rollback-canary ]
    if: needs.detect-release-mode.outputs.is_rollback == 'true'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Canary approved
        run: echo "Rollback canary approved for promotion to production"

  promote-rollback-to-production:
    name: Promote rollback to production for ${{ matrix.service-name }}
    needs: [ detect-release-mode, prepare-services, approve-rollback-canary ]
    if: needs.detect-release-mode.outputs.is_rollback == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-release-mode.outputs.source_branch }}

      - name: Setup Yandex Cloud
        uses: ./.github/workflows/jobs/setup-yandex-cloud
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
          yc-cloud-id: ${{ secrets.YC_CLOUD_ID }}
          yc-folder-id: ${{ secrets.YC_FOLDER_ID }}
          yc-k8s-cluster-id: ${{ secrets.YC_K8S_CLUSTER_ID }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Promote to production
        uses: ./.github/workflows/jobs/deploy-helm
        with:
          service-name: ${{ matrix.service-name }}
          service-type: ${{ needs.prepare-services.outputs.service-type }}
          version: ${{ needs.detect-release-mode.outputs.rollback_version }}
          docker-hub-username: ${{ secrets.DOCKER_HUB_USERNAME }}
          canary-enabled: 'false'
          atomic: 'true'

  # ============================================
  # NORMAL RELEASE FLOW
  # ============================================

  get-latest-release-version:
    name: Get latest release version for ${{ matrix.service-name }}
    needs: [ detect-release-mode, prepare-services ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install GitHub CLI
        uses: ./.github/workflows/jobs/install-github-cli

      - name: Get latest release version
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ALL_RELEASES=$(gh release list --repo "$GITHUB_REPOSITORY" --limit 100 || echo "")
          LATEST_RELEASE=$(echo "$ALL_RELEASES" | grep -E "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+\s" | head -n 1 | awk '{print $1}' || echo "")

          if [ -z "$LATEST_RELEASE" ]; then
            echo "Trying to find release via git tags..."
            ALL_TAGS=$(git tag -l "${SERVICE_NAME}-v*" || echo "")
            LATEST_NON_ROLLBACK=$(echo "$ALL_TAGS" | grep -E "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n 1 || echo "")
            LATEST_ROLLBACK_TAG=$(echo "$ALL_TAGS" | grep -E "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+-[a-f0-9]+$" | sort -V | tail -n 1 || echo "")

            if [ -n "$LATEST_NON_ROLLBACK" ]; then
              LATEST_RELEASE="$LATEST_NON_ROLLBACK"
            elif [ -n "$LATEST_ROLLBACK_TAG" ]; then
              LATEST_RELEASE="$LATEST_ROLLBACK_TAG"
            fi
          fi

          if [ -z "$LATEST_RELEASE" ]; then
            VERSION="0.0.0"
            RELEASE_TAG=""
            echo "No previous release found for $SERVICE_NAME, using version: $VERSION"
          else
            if echo "$LATEST_RELEASE" | grep -qE "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+-[a-f0-9]+$"; then
              VERSION=$(echo "$LATEST_RELEASE" | sed -E "s/^${SERVICE_NAME}-v([0-9]+\.[0-9]+\.[0-9]+)-.*/\1/")
            else
              VERSION=$(echo "$LATEST_RELEASE" | sed "s/^${SERVICE_NAME}-v//")
            fi
            RELEASE_TAG="$LATEST_RELEASE"
            echo "Latest release for $SERVICE_NAME: $LATEST_RELEASE, base version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

      - name: Save version files
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          VERSION: ${{ steps.get-version.outputs.version }}
          RELEASE_TAG: ${{ steps.get-version.outputs.release_tag }}
        run: |
          echo "$VERSION" > "version_${SERVICE_NAME}.txt"
          echo "$RELEASE_TAG" > "release_tag_${SERVICE_NAME}.txt"

      - name: Upload version files
        uses: actions/upload-artifact@v4
        with:
          name: version-${{ matrix.service-name }}
          path: |
            version_${{ matrix.service-name }}.txt
            release_tag_${{ matrix.service-name }}.txt

  calculate-new-version:
    name: Calculate new version for ${{ matrix.service-name }}
    needs: [ detect-release-mode, prepare-services, get-latest-release-version ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download version files
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.service-name }}

      - name: Calculate new version from commits
        id: calculate-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          CURRENT_VERSION=$(cat "version_${SERVICE_NAME}.txt")
          RELEASE_TAG=$(cat "release_tag_${SERVICE_NAME}.txt")

          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          if [ -z "$RELEASE_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s" --reverse)
          else
            COMMITS=$(git log $RELEASE_TAG..HEAD --pretty=format:"%s" --reverse || git log --pretty=format:"%s" --reverse)
          fi

          HAS_MAJOR=false HAS_MINOR=false HAS_FIX=false HAS_CHORE=false
          CHANGELOG=""

          while IFS= read -r commit_msg; do
            [ -z "$commit_msg" ] && continue
            CHANGELOG="${CHANGELOG}- ${commit_msg}\n"
            case "$commit_msg" in
              major:*) HAS_MAJOR=true ;;
              minor:*) HAS_MINOR=true ;;
              fix:*) HAS_FIX=true ;;
              chore:*) HAS_CHORE=true ;;
            esac
          done <<< "$COMMITS"

          IS_ROLLBACK=false ROLLBACK_HASH=""

          if [ "$HAS_CHORE" = true ] && [ "$HAS_MAJOR" = false ] && [ "$HAS_MINOR" = false ] && [ "$HAS_FIX" = false ]; then
            IS_ROLLBACK=true
            ROLLBACK_HASH=$(date +%s | sha256sum | head -c 8)
            NEW_VERSION="$CURRENT_VERSION"
          elif [ "$HAS_MAJOR" = true ]; then
            NEW_VERSION="$((MAJOR + 1)).0.0"
          elif [ "$HAS_MINOR" = true ]; then
            NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
          elif [ "$HAS_FIX" = true ]; then
            NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
          else
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "Current: $CURRENT_VERSION -> New: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "is_rollback=$IS_ROLLBACK" >> $GITHUB_OUTPUT
          echo "rollback_hash=$ROLLBACK_HASH" >> $GITHUB_OUTPUT

          echo "$NEW_VERSION" > "new_version_${SERVICE_NAME}.txt"
          echo "$IS_ROLLBACK" > "is_rollback_${SERVICE_NAME}.txt"
          echo "$ROLLBACK_HASH" > "rollback_hash_${SERVICE_NAME}.txt"
          echo -e "$CHANGELOG" > "changelog_${SERVICE_NAME}.txt"

      - name: Upload new version files
        uses: actions/upload-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
          path: |
            new_version_${{ matrix.service-name }}.txt
            is_rollback_${{ matrix.service-name }}.txt
            rollback_hash_${{ matrix.service-name }}.txt
            changelog_${{ matrix.service-name }}.txt

  security-checks:
    name: Security checks for ${{ matrix.service-name }}
    needs: [ detect-release-mode, prepare-services ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Security scan check for NestJS
        if: needs.prepare-services.outputs.service-type == 'nest'
        uses: ./.github/workflows/jobs/nest-application-security-check
        with:
          service-name: ${{ matrix.service-name }}

      - name: Security scan check for Next.js
        if: needs.prepare-services.outputs.service-type == 'next'
        uses: ./.github/workflows/jobs/next-application-security-check
        with:
          service-name: ${{ matrix.service-name }}

  build-image-to-docker-hub:
    name: Build and push image for ${{ matrix.service-name }}
    needs:
      [
        detect-release-mode,
        prepare-services,
        security-checks,
        calculate-new-version
      ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Get version for service
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt" | tr -d '[:space:]')

          if [ -z "$VERSION" ] || ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Error: Invalid version format: $VERSION"
            exit 1
          fi

          echo "Building $SERVICE_NAME with version $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./services/${{ matrix.service-name }}/Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/supreme:production-${{
            matrix.service-name }}-v${{ steps.get-version.outputs.version }}
          cache-to: type=inline

  create-release-branch:
    name: Create release branch for ${{ matrix.service-name }}
    needs: [ detect-release-mode, prepare-services, calculate-new-version ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Configure Git
        run: |
          git config --global user.email "246592117+madara-robot@users.noreply.github.com"
          git config --global user.name "madara-robot"

      - name: Create release branch
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt")
          BRANCH_NAME="releases/production/${SERVICE_NAME}-${VERSION}"

          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists"
          else
            git checkout -b "$BRANCH_NAME"
            git push -u origin "$BRANCH_NAME"
            echo "Created branch $BRANCH_NAME"
          fi

  create-github-release:
    name: Create GitHub release for ${{ matrix.service-name }}
    needs:
      [
        detect-release-mode,
        prepare-services,
        build-image-to-docker-hub,
        calculate-new-version,
        create-release-branch
      ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download new version files
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Install GitHub CLI
        uses: ./.github/workflows/jobs/install-github-cli

      - name: Prepare release info
        id: get-release-info
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt")
          IS_ROLLBACK=$(cat "is_rollback_${SERVICE_NAME}.txt" 2>/dev/null || echo "false")
          ROLLBACK_HASH=$(cat "rollback_hash_${SERVICE_NAME}.txt" 2>/dev/null || echo "")
          CHANGELOG=$(cat "changelog_${SERVICE_NAME}.txt" 2>/dev/null || echo "")

          if [ "$IS_ROLLBACK" = "true" ] && [ -n "$ROLLBACK_HASH" ]; then
            TAG_NAME="${SERVICE_NAME}-v${VERSION}-${ROLLBACK_HASH}"
            RELEASE_NAME="Rollback ${SERVICE_NAME} v${VERSION}"
          else
            TAG_NAME="${SERVICE_NAME}-v${VERSION}"
            RELEASE_NAME="Release ${SERVICE_NAME} v${VERSION}"
          fi

          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT

            CHANGELOG_LINES=$(echo "$CHANGELOG" | wc -l)

          {
            echo "$RELEASE_NAME"
            echo ""
            echo "## Changelog"
            if [ -n "$CHANGELOG" ]; then
              if [ "$CHANGELOG_LINES" -gt 12 ]; then
                echo "<details><summary>view full changelog</summary>"
                echo ""
                echo "$CHANGELOG"
                echo ""
                echo "</details>"
              else
                echo "$CHANGELOG"
              fi
            else
              echo "No changes"
            fi
            echo ""
            echo "## Docker Image"
            echo "\`$DOCKER_HUB_USERNAME/supreme:production-${SERVICE_NAME}-v$VERSION\`"
          } > "release_body_${SERVICE_NAME}.txt"

      - name: Create GitHub Release
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          TAG_NAME: ${{ steps.get-release-info.outputs.tag_name }}
          RELEASE_NAME: ${{ steps.get-release-info.outputs.release_name }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BODY_FILE="release_body_${SERVICE_NAME}.txt"

          if gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release $TAG_NAME already exists, skipping"
            exit 0
          fi

          echo "Creating release $TAG_NAME"
          gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --notes-file "$BODY_FILE" \
            --repo "$GITHUB_REPOSITORY"

  # ============================================
  # CANARY DEPLOYMENT (Normal Release)
  # ============================================

  deploy-canary:
    name: Deploy canary for ${{ matrix.service-name }}
    needs:
      [
        detect-release-mode,
        prepare-services,
        build-image-to-docker-hub,
        create-github-release,
        calculate-new-version
      ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    environment: canary
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Get version
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt" | tr -d '[:space:]')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup Yandex Cloud
        uses: ./.github/workflows/jobs/setup-yandex-cloud
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
          yc-cloud-id: ${{ secrets.YC_CLOUD_ID }}
          yc-folder-id: ${{ secrets.YC_FOLDER_ID }}
          yc-k8s-cluster-id: ${{ secrets.YC_K8S_CLUSTER_ID }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Get current replica count
        id: get-replicas
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          CURRENT_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "2")
          CANARY_REPLICAS=$(( (CURRENT_REPLICAS + 1) / 2 ))
          [ "$CANARY_REPLICAS" -lt 1 ] && CANARY_REPLICAS=1
          echo "canary_replicas=$CANARY_REPLICAS" >> $GITHUB_OUTPUT

      - name: Deploy canary with Helm
        uses: ./.github/workflows/jobs/deploy-helm
        with:
          service-name: ${{ matrix.service-name }}
          service-type: ${{ needs.prepare-services.outputs.service-type }}
          version: ${{ steps.get-version.outputs.version }}
          docker-hub-username: ${{ secrets.DOCKER_HUB_USERNAME }}
          canary-enabled: 'true'
          canary-replicas: ${{ steps.get-replicas.outputs.canary_replicas }}

  approve-canary:
    name: Approve canary promotion to production
    needs: [ detect-release-mode, prepare-services, deploy-canary ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Canary approved
        run: echo "Canary approved for promotion to production"

  promote-to-production:
    name: Promote to production for ${{ matrix.service-name }}
    needs:
      [
        detect-release-mode,
        prepare-services,
        approve-canary,
        calculate-new-version
      ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Get version
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt" | tr -d '[:space:]')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup Yandex Cloud
        uses: ./.github/workflows/jobs/setup-yandex-cloud
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
          yc-cloud-id: ${{ secrets.YC_CLOUD_ID }}
          yc-folder-id: ${{ secrets.YC_FOLDER_ID }}
          yc-k8s-cluster-id: ${{ secrets.YC_K8S_CLUSTER_ID }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Promote to production
        uses: ./.github/workflows/jobs/deploy-helm
        with:
          service-name: ${{ matrix.service-name }}
          service-type: ${{ needs.prepare-services.outputs.service-type }}
          version: ${{ steps.get-version.outputs.version }}
          docker-hub-username: ${{ secrets.DOCKER_HUB_USERNAME }}
          canary-enabled: 'false'
          atomic: 'true'
