name: Create Release Pipeline

on:
  workflow_dispatch:
    inputs:
      service:
        description: "Select service to deploy"
        required: true
        type: choice
        # List of available services (auto-generated)
        options:
          - core-auth-bff
          - core-recipes-bff
          - frontend
          - auth-ssr
          - web-documents-ssr
          - web-profile-ssr
        default: "core-auth-bff"
      # TODO: remove after development (or comment me)
      skip-canary:
        description: "Skip canary deployment and go directly to production"
        required: false
        type: boolean
        default: false

env:
  HELM_VERSION: "v3.16.3"

jobs:
  # ============================================
  # DETECTION & PREPARATION
  # ============================================

  detect-release-mode:
    name: Detect release mode
    runs-on: ubuntu-latest
    outputs:
      is_rollback: ${{ steps.detect.outputs.is_rollback }}
      rollback_version: ${{ steps.detect.outputs.rollback_version }}
      source_branch: ${{ steps.detect.outputs.source_branch }}
    steps:
      - name: Detect release mode
        id: detect
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          SERVICE_NAME="${{ github.event.inputs.service }}"

          echo "Workflow triggered from branch: $BRANCH_NAME"

          # Check if this is a release branch (rollback) or main branch (normal release)
          if [[ "$BRANCH_NAME" =~ ^releases/production/${SERVICE_NAME}-([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
            echo "Rollback mode detected"
            echo "Rollback version: $VERSION"
            echo "is_rollback=true" >> $GITHUB_OUTPUT
            echo "rollback_version=$VERSION" >> $GITHUB_OUTPUT
            echo "source_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          elif [ "$BRANCH_NAME" = "main" ]; then
            echo "Normal release mode from main"
            echo "is_rollback=false" >> $GITHUB_OUTPUT
            echo "rollback_version=" >> $GITHUB_OUTPUT
            echo "source_branch=main" >> $GITHUB_OUTPUT
          else
            echo "Error: Workflow must be run from 'main' branch for normal release"
            echo "       or from 'releases/production/{service}-{version}' branch for rollback"
            echo ""
            echo "Current branch: $BRANCH_NAME"
            echo "Expected rollback branch format: releases/production/${SERVICE_NAME}-X.Y.Z"
            exit 1
          fi

  prepare-services:
    name: Prepare services list
    needs: detect-release-mode
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set-services.outputs.services }}
      service-type: ${{ steps.set-services.outputs.service-type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set services list
        id: set-services
        run: |
          SELECTED_SERVICE="${{ github.event.inputs.service }}"

          if ! command -v yq &> /dev/null; then
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi

          IS_NEST=$(yq eval ".services.nest[] | select(.name == \"$SELECTED_SERVICE\") | .name" services.yaml)
          IS_NEXT=$(yq eval ".services.next[] | select(.name == \"$SELECTED_SERVICE\") | .name" services.yaml)

          if [ -n "$IS_NEST" ]; then
            SERVICE_TYPE="nest"
          elif [ -n "$IS_NEXT" ]; then
            SERVICE_TYPE="next"
          else
            echo "Error: Service $SELECTED_SERVICE not found in services.yaml"
            exit 1
          fi

          SERVICES_JSON=$(echo "$SELECTED_SERVICE" | jq -R -c '[.]')

          echo "Selected service: $SELECTED_SERVICE"
          echo "Service type: $SERVICE_TYPE"
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "service-type=$SERVICE_TYPE" >> $GITHUB_OUTPUT

  # ============================================
  # VERSION CALCULATION
  # ============================================

  get-latest-release-version:
    name: Get latest release version for ${{ matrix.service-name }}
    needs: [detect-release-mode, prepare-services]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.save-output.outputs.version }}
      release_tag: ${{ steps.save-output.outputs.release_tag }}
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest release version
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          # Get all tags for this service, sorted by version
          ALL_TAGS=$(git tag -l "${SERVICE_NAME}-v*" 2>/dev/null | grep -E "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V || echo "")

          echo "All tags for ${SERVICE_NAME}:"
          echo "$ALL_TAGS"

          LATEST_TAG=$(echo "$ALL_TAGS" | tail -n 1)

          if [ -z "$LATEST_TAG" ]; then
            VERSION="0.0.0"
            RELEASE_TAG=""
            echo "No previous release found for $SERVICE_NAME, starting from version: $VERSION"
          else
            VERSION=$(echo "$LATEST_TAG" | sed "s/^${SERVICE_NAME}-v//")
            RELEASE_TAG="$LATEST_TAG"
            echo "Latest release for $SERVICE_NAME: $LATEST_TAG, version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

      - name: Save version files
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          VERSION: ${{ steps.get-version.outputs.version }}
          RELEASE_TAG: ${{ steps.get-version.outputs.release_tag }}
        run: |
          echo "$VERSION" > "version_${SERVICE_NAME}.txt"
          echo "$RELEASE_TAG" > "release_tag_${SERVICE_NAME}.txt"

      - name: Save output for next jobs
        id: save-output
        env:
          VERSION: ${{ steps.get-version.outputs.version }}
          RELEASE_TAG: ${{ steps.get-version.outputs.release_tag }}
        run: |
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

      - name: Upload version files
        uses: actions/upload-artifact@v4
        with:
          name: version-${{ matrix.service-name }}
          path: |
            version_${{ matrix.service-name }}.txt
            release_tag_${{ matrix.service-name }}.txt

  calculate-new-version:
    name: Calculate new version for ${{ matrix.service-name }}
    needs: [detect-release-mode, prepare-services, get-latest-release-version]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.save-output.outputs.version }}
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download version files
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.service-name }}

      - name: Handle rollback version
        if: needs.detect-release-mode.outputs.is_rollback == 'true'
        id: rollback-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          ROLLBACK_VERSION: ${{ needs.detect-release-mode.outputs.rollback_version }}
        run: |
          echo "Rollback mode: using version $ROLLBACK_VERSION"
          echo "$ROLLBACK_VERSION" > "new_version_${SERVICE_NAME}.txt"
          echo "" > "changelog_${SERVICE_NAME}.txt"
          echo "version=$ROLLBACK_VERSION" >> $GITHUB_OUTPUT

      - name: Calculate new version from commits
        if: needs.detect-release-mode.outputs.is_rollback == 'false'
        id: calculate-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          CURRENT_VERSION=$(cat "version_${SERVICE_NAME}.txt")
          RELEASE_TAG=$(cat "release_tag_${SERVICE_NAME}.txt")

          echo "Current version: $CURRENT_VERSION"
          echo "Release tag: $RELEASE_TAG"

          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          if [ -z "$RELEASE_TAG" ]; then
            echo "No previous release tag, getting all commits"
            COMMITS=$(git log --pretty=format:"%s" --reverse)
          else
            echo "Getting commits since $RELEASE_TAG"
            COMMITS=$(git log "$RELEASE_TAG"..HEAD --pretty=format:"%s" --reverse 2>/dev/null || git log --pretty=format:"%s" --reverse)
          fi

          echo "Commits to analyze:"
          echo "$COMMITS"

          HAS_MAJOR=false
          HAS_MINOR=false
          HAS_FIX=false
          CHANGELOG=""

          while IFS= read -r commit_msg; do
            [ -z "$commit_msg" ] && continue
            CHANGELOG="${CHANGELOG}- ${commit_msg}\n"
            case "$commit_msg" in
              major:*|BREAKING*) HAS_MAJOR=true ;;
              minor:*|feat:*) HAS_MINOR=true ;;
              fix:*|patch:*) HAS_FIX=true ;;
            esac
          done <<< "$COMMITS"

          if [ "$HAS_MAJOR" = true ]; then
            NEW_VERSION="$((MAJOR + 1)).0.0"
          elif [ "$HAS_MINOR" = true ]; then
            NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
          elif [ "$HAS_FIX" = true ]; then
            NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
          else
            # Default: increment patch
            NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
          fi

          echo "Version bump: $CURRENT_VERSION -> $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

          echo "$NEW_VERSION" > "new_version_${SERVICE_NAME}.txt"
          echo -e "$CHANGELOG" > "changelog_${SERVICE_NAME}.txt"

      - name: Save output for next jobs
        id: save-output
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          IS_ROLLBACK: ${{ needs.detect-release-mode.outputs.is_rollback }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt")
          echo "Final version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Upload new version files
        uses: actions/upload-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
          path: |
            new_version_${{ matrix.service-name }}.txt
            changelog_${{ matrix.service-name }}.txt

  # ============================================
  # SECURITY & BUILD (Skip for rollback)
  # ============================================

  # security-checks:
  #   name: Security checks for ${{ matrix.service-name }}
  #   needs: [ detect-release-mode, prepare-services ]
  #   if: needs.detect-release-mode.outputs.is_rollback == 'false'
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Security scan check for NestJS
  #       if: needs.prepare-services.outputs.service-type == 'nest'
  #       uses: ./.github/workflows/jobs/nest-application-security-check
  #       with:
  #         service-name: ${{ matrix.service-name }}

  #     - name: Security scan check for Next.js
  #       if: needs.prepare-services.outputs.service-type == 'next'
  #       uses: ./.github/workflows/jobs/next-application-security-check
  #       with:
  #         service-name: ${{ matrix.service-name }}

  build-image-to-docker-hub:
    name: Build and push image for ${{ matrix.service-name }}
    needs: [
        detect-release-mode,
        prepare-services,
        # security-checks,
        calculate-new-version,
      ]
    if: needs.detect-release-mode.outputs.is_rollback == 'false'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Get version for service
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt" | tr -d '[:space:]')

          if [ -z "$VERSION" ] || ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Error: Invalid version format: '$VERSION'"
            exit 1
          fi

          echo "Building $SERVICE_NAME with version $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./services/${{ matrix.service-name }}/Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/supreme:production-${{
            matrix.service-name }}-v${{ steps.get-version.outputs.version }}
          cache-to: type=inline

  # ============================================
  # RELEASE BRANCH & GITHUB RELEASE
  # ============================================

  create-release-branch:
    name: Create release branch for ${{ matrix.service-name }}
    needs: [detect-release-mode, prepare-services, calculate-new-version, build-image-to-docker-hub]
    if: |
      always() &&
      needs.calculate-new-version.result == 'success' &&
      (needs.build-image-to-docker-hub.result == 'success' || needs.detect-release-mode.outputs.is_rollback == 'true')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-release-mode.outputs.source_branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Configure Git
        run: |
          git config --global user.email "246592117+madara-robot@users.noreply.github.com"
          git config --global user.name "madara-robot"

      - name: Create or update release branch
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          IS_ROLLBACK: ${{ needs.detect-release-mode.outputs.is_rollback }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt")
          BRANCH_NAME="releases/production/${SERVICE_NAME}-${VERSION}"

          # Fetch all branches
          git fetch origin

          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists"
            
            # For rollback: rebase onto main
            if [ "$IS_ROLLBACK" = "true" ]; then
              echo "Rebasing $BRANCH_NAME onto main..."
              git checkout "$BRANCH_NAME"
              git rebase origin/main
              git push origin "$BRANCH_NAME" --force
              echo "Successfully rebased $BRANCH_NAME onto main"
            fi
          else
            echo "Creating new branch $BRANCH_NAME"
            git checkout -b "$BRANCH_NAME"
            git push -u origin "$BRANCH_NAME"
            echo "Created branch $BRANCH_NAME"
          fi

  create-github-release:
    name: Create GitHub release for ${{ matrix.service-name }}
    needs: [detect-release-mode, prepare-services, calculate-new-version, create-release-branch]
    if: |
      always() &&
      needs.create-release-branch.result == 'success'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download new version files
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Install GitHub CLI
        uses: ./.github/workflows/jobs/install-github-cli

      - name: Prepare release info
        id: get-release-info
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          IS_ROLLBACK: ${{ needs.detect-release-mode.outputs.is_rollback }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt")
          CHANGELOG=$(cat "changelog_${SERVICE_NAME}.txt" 2>/dev/null || echo "")

          if [ "$IS_ROLLBACK" = "true" ]; then
            # For rollback: create unique tag with hash
            RELEASE_NAME="Rollback ${SERVICE_NAME} to v${VERSION}"
            TIMESTAMP=$(date +%s)
            HASH=$(echo -n "${RELEASE_NAME}${TIMESTAMP}" | sha256sum | head -c 8)
            TAG_NAME="${SERVICE_NAME}-rollback-v${VERSION}-${HASH}"
          else
            TAG_NAME="${SERVICE_NAME}-v${VERSION}"
            RELEASE_NAME="Release ${SERVICE_NAME} v${VERSION}"
          fi

          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT

          CHANGELOG_LINES=$(echo "$CHANGELOG" | wc -l)

          {
            echo "# $RELEASE_NAME"
            echo ""
            if [ "$IS_ROLLBACK" = "true" ]; then
              echo "## ⚠️ Rollback"
              echo "This is a rollback to a previous version."
              echo ""
            fi
            echo "## Changelog"
            if [ -n "$CHANGELOG" ] && [ "$IS_ROLLBACK" != "true" ]; then
              if [ "$CHANGELOG_LINES" -gt 12 ]; then
                echo "<details><summary>view full changelog</summary>"
                echo ""
                echo "$CHANGELOG"
                echo ""
                echo "</details>"
              else
                echo "$CHANGELOG"
              fi
            else
              echo "No changes"
            fi
            echo ""
            echo "## Docker Image"
            echo "\`$DOCKER_HUB_USERNAME/supreme:production-${SERVICE_NAME}-v$VERSION\`"
          } > "release_body_${SERVICE_NAME}.txt"

      - name: Create GitHub Release
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
          TAG_NAME: ${{ steps.get-release-info.outputs.tag_name }}
          RELEASE_NAME: ${{ steps.get-release-info.outputs.release_name }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BODY_FILE="release_body_${SERVICE_NAME}.txt"

          if gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release $TAG_NAME already exists, skipping"
            exit 0
          fi

          echo "Creating release $TAG_NAME"
          gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --notes-file "$BODY_FILE" \
            --repo "$GITHUB_REPOSITORY"

  # ============================================
  # CANARY DEPLOYMENT (Skip for rollback)
  # ============================================

  deploy-canary:
    name: Deploy canary for ${{ matrix.service-name }}
    needs: [detect-release-mode, prepare-services, calculate-new-version, create-release-branch, create-github-release]
    if: |
      always() &&
      needs.create-release-branch.result == 'success' &&
      needs.detect-release-mode.outputs.is_rollback == 'false' &&
      github.event.inputs.skip-canary != 'true'
    runs-on: ubuntu-latest
    environment: canary
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Get version
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt" | tr -d '[:space:]')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup Yandex Cloud
        uses: ./.github/workflows/jobs/setup-yandex-cloud
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
          yc-cloud-id: ${{ secrets.YC_CLOUD_ID }}
          yc-folder-id: ${{ secrets.YC_FOLDER_ID }}
          yc-k8s-cluster-id: ${{ secrets.YC_K8S_CLUSTER_ID }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Get current replica count
        id: get-replicas
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          CURRENT_REPLICAS=$(kubectl get deployment "$SERVICE_NAME" -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "2")
          CANARY_REPLICAS=$(( (CURRENT_REPLICAS + 1) / 2 ))
          [ "$CANARY_REPLICAS" -lt 1 ] && CANARY_REPLICAS=1
          echo "canary_replicas=$CANARY_REPLICAS" >> $GITHUB_OUTPUT

      - name: Get database password secret name
        id: get-db-secret
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          if ! command -v yq &> /dev/null; then
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi

          # Check in nest services
          DB_SECRET=$(yq eval ".services.nest[] | select(.name == \"$SERVICE_NAME\") | .database.passwordSecret" services.yaml)

          # If not found in nest, check next services
          if [ -z "$DB_SECRET" ] || [ "$DB_SECRET" = "null" ]; then
            DB_SECRET=$(yq eval ".services.next[] | select(.name == \"$SERVICE_NAME\") | .database.passwordSecret" services.yaml)
          fi

          # Default to DB_PASSWORD if not specified
          if [ -z "$DB_SECRET" ] || [ "$DB_SECRET" = "null" ]; then
            DB_SECRET="DB_PASSWORD"
          fi

          echo "secret_name=$DB_SECRET" >> $GITHUB_OUTPUT
          echo "Using database password secret: $DB_SECRET"

      - name: Deploy canary with Helm
        uses: ./.github/workflows/jobs/deploy-helm
        with:
          service-name: ${{ matrix.service-name }}
          service-type: ${{ needs.prepare-services.outputs.service-type }}
          version: ${{ steps.get-version.outputs.version }}
          docker-hub-username: ${{ secrets.DOCKER_HUB_USERNAME }}
          canary-enabled: "true"
          canary-replicas: ${{ steps.get-replicas.outputs.canary_replicas }}
          jwt-secret: ${{ secrets.JWT_SECRET }}
          db-password: ${{ secrets[steps.get-db-secret.outputs.secret_name] }}

  approve-canary:
    name: Approve canary promotion to production
    needs: [detect-release-mode, prepare-services, deploy-canary, calculate-new-version]
    if: |
      always() &&
      needs.deploy-canary.result == 'success' &&
      needs.detect-release-mode.outputs.is_rollback == 'false' &&
      github.event.inputs.skip-canary != 'true'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ github.event.inputs.service }}

      - name: Get version
        id: get-version
        env:
          SERVICE_NAME: ${{ github.event.inputs.service }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt" | tr -d '[:space:]')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Wait for manual approval
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ${{ github.actor }}
          minimum-approvals: 1
          issue-title: "Approve canary promotion: ${{ github.event.inputs.service }} v${{
            steps.get-version.outputs.version }}"
          issue-body: |
            Canary deployment completed for **${{ github.event.inputs.service }}** version **v${{ steps.get-version.outputs.version }}**.

            Please verify the canary pods are working correctly before approving promotion to production.

            **To approve:** Comment `approve` or `lgtm`
            **To deny:** Comment `deny`
          exclude-workflow-initiator-as-approver: false
        timeout-minutes: 60

  # ============================================
  # PRODUCTION DEPLOYMENT
  # ============================================

  promote-to-production:
    name: Promote to production for ${{ matrix.service-name }}
    needs:
      [
        detect-release-mode,
        prepare-services,
        calculate-new-version,
        create-release-branch,
        create-github-release,
        approve-canary,
      ]
    if: |
      always() &&
      needs.create-release-branch.result == 'success' &&
      needs.create-github-release.result == 'success' &&
      (needs.approve-canary.result == 'success' || needs.approve-canary.result == 'skipped' || needs.detect-release-mode.outputs.is_rollback == 'true' || github.event.inputs.skip-canary == 'true')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.detect-release-mode.outputs.source_branch }}

      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}

      - name: Get version
        id: get-version
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          VERSION=$(cat "new_version_${SERVICE_NAME}.txt" | tr -d '[:space:]')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup Yandex Cloud
        uses: ./.github/workflows/jobs/setup-yandex-cloud
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
          yc-cloud-id: ${{ secrets.YC_CLOUD_ID }}
          yc-folder-id: ${{ secrets.YC_FOLDER_ID }}
          yc-k8s-cluster-id: ${{ secrets.YC_K8S_CLUSTER_ID }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Get database password secret name
        id: get-db-secret
        env:
          SERVICE_NAME: ${{ matrix.service-name }}
        run: |
          if ! command -v yq &> /dev/null; then
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi

          # Check in nest services
          DB_SECRET=$(yq eval ".services.nest[] | select(.name == \"$SERVICE_NAME\") | .database.passwordSecret" services.yaml)

          # If not found in nest, check next services
          if [ -z "$DB_SECRET" ] || [ "$DB_SECRET" = "null" ]; then
            DB_SECRET=$(yq eval ".services.next[] | select(.name == \"$SERVICE_NAME\") | .database.passwordSecret" services.yaml)
          fi

          # Default to DB_PASSWORD if not specified
          if [ -z "$DB_SECRET" ] || [ "$DB_SECRET" = "null" ]; then
            DB_SECRET="DB_PASSWORD"
          fi

          echo "secret_name=$DB_SECRET" >> $GITHUB_OUTPUT
          echo "Using database password secret: $DB_SECRET"

      - name: Promote to production
        uses: ./.github/workflows/jobs/deploy-helm
        with:
          service-name: ${{ matrix.service-name }}
          service-type: ${{ needs.prepare-services.outputs.service-type }}
          version: ${{ steps.get-version.outputs.version }}
          docker-hub-username: ${{ secrets.DOCKER_HUB_USERNAME }}
          canary-enabled: "false"
          atomic: "true"
          jwt-secret: ${{ secrets.JWT_SECRET }}
          db-password: ${{ secrets[steps.get-db-secret.outputs.secret_name] }}
