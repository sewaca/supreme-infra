name: Create Release Pipeline 

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Select service to deploy'
        required: true
        type: choice
        options:
          - backend
          - frontend
        default: 'backend'

jobs:
  prepare-services:
    name: Prepare services list
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set-services.outputs.services }}
      service-type: ${{ steps.set-services.outputs.service-type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set services list
        id: set-services
        run: |
          # Get selected service
          SELECTED_SERVICE="${{ github.event.inputs.service }}"

          # Install jq if not available
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # Read services.json to determine service type
          SERVICES_JSON_FILE="infra/generate-service/services.json"

          # Check if service is in nest array
          IS_NEST=$(jq -r --arg service "$SELECTED_SERVICE" '.nest | index($service) != null' "$SERVICES_JSON_FILE")
          # Check if service is in next array
          IS_NEXT=$(jq -r --arg service "$SELECTED_SERVICE" '.next | index($service) != null' "$SERVICES_JSON_FILE")

          if [ "$IS_NEST" = "true" ]; then
            SERVICE_TYPE="nest"
          elif [ "$IS_NEXT" = "true" ]; then
            SERVICE_TYPE="next"
          else
            echo "Error: Service $SELECTED_SERVICE not found in services.json"
            exit 1
          fi

          # Convert to JSON array (single service wrapped in array)
          SERVICES_JSON=$(echo "$SELECTED_SERVICE" | jq -R -c '[.]')

          echo "Selected service: $SELECTED_SERVICE"
          echo "Service type: $SERVICE_TYPE"
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "service-type=$SERVICE_TYPE" >> $GITHUB_OUTPUT
          echo "Services JSON: $SERVICES_JSON"

  get-latest-release-version:
    name: Get latest release version for ${{ matrix.service-name }}
    needs: prepare-services
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y
      - name: Get latest release version
        id: get-version
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"

          # Get all releases and filter by service name pattern
          # gh release list format: TAG_NAME  TITLE  (draft/prerelease)
          ALL_RELEASES=$(gh release list --repo ${{ github.repository }} --limit 100 || echo "")

          # Find the latest release tag matching the pattern ${SERVICE_NAME}-v*
          # Exclude rollback releases (those with hash suffix like -abc12345)
          # Pattern: service-v1.2.3 (but not service-v1.2.3-hash)
          LATEST_RELEASE=$(echo "$ALL_RELEASES" | grep -E "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+$" | head -n 1 | awk '{print $1}' || echo "")

          # Alternative: try to get releases via git tags
          if [ -z "$LATEST_RELEASE" ]; then
            echo "Trying to find release via git tags..."
            # Get all tags matching pattern
            ALL_TAGS=$(git tag -l "${SERVICE_NAME}-v*" || echo "")

            # First, try to find non-rollback tags (exact version match: service-v1.2.3)
            LATEST_NON_ROLLBACK=$(echo "$ALL_TAGS" | grep -E "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n 1 || echo "")

            # Also find latest rollback tag if it exists
            LATEST_ROLLBACK_TAG=$(echo "$ALL_TAGS" | grep -E "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+-[a-f0-9]+$" | sort -V | tail -n 1 || echo "")

            # Use non-rollback tag if available, otherwise extract base version from rollback tag
            if [ -n "$LATEST_NON_ROLLBACK" ]; then
              LATEST_RELEASE="$LATEST_NON_ROLLBACK"
            elif [ -n "$LATEST_ROLLBACK_TAG" ]; then
              # Extract base version from rollback tag (remove hash suffix)
              BASE_VERSION=$(echo "$LATEST_ROLLBACK_TAG" | sed -E "s/^${SERVICE_NAME}-v([0-9]+\.[0-9]+\.[0-9]+)-.*/\1/")
              # Use the rollback tag itself for git log, but store base version for calculation
              LATEST_RELEASE="$LATEST_ROLLBACK_TAG"
              echo "Found rollback tag $LATEST_ROLLBACK_TAG, base version: $BASE_VERSION"
            fi
          fi

          if [ -z "$LATEST_RELEASE" ]; then
            VERSION="0.0.0"
            RELEASE_TAG=""
            echo "No previous release found for $SERVICE_NAME, using version: $VERSION"
          else
            # Extract version from tag (remove service-v prefix)
            # For rollback tags like service-v1.0.0-hash, extract base version
            if echo "$LATEST_RELEASE" | grep -qE "^${SERVICE_NAME}-v[0-9]+\.[0-9]+\.[0-9]+-[a-f0-9]+$"; then
              # Rollback tag: extract base version (remove hash suffix)
              VERSION=$(echo "$LATEST_RELEASE" | sed -E "s/^${SERVICE_NAME}-v([0-9]+\.[0-9]+\.[0-9]+)-.*/\1/")
            else
              # Regular tag: extract version normally
              VERSION=$(echo "$LATEST_RELEASE" | sed "s/^${SERVICE_NAME}-v//")
            fi
            RELEASE_TAG="$LATEST_RELEASE"
            echo "Latest release for $SERVICE_NAME: $LATEST_RELEASE, base version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "service=$SERVICE_NAME" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Save version and tag to file
        run: |
          echo "${{ steps.get-version.outputs.version }}" > version_${{ matrix.service-name }}.txt
          echo "${{ steps.get-version.outputs.release_tag }}" > release_tag_${{ matrix.service-name }}.txt
      - name: Upload version files
        uses: actions/upload-artifact@v4
        with:
          name: version-${{ matrix.service-name }}
          path: |
            version_${{ matrix.service-name }}.txt
            release_tag_${{ matrix.service-name }}.txt

  calculate-new-version:
    name: Calculate new version for ${{ matrix.service-name }}
    needs: [prepare-services, get-latest-release-version]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y
      - name: Download version files
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.service-name }}
      - name: Calculate new version from commits
        id: calculate-version
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          CURRENT_VERSION=$(cat version_$SERVICE_NAME.txt)
          RELEASE_TAG=$(cat release_tag_$SERVICE_NAME.txt)

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Get commits since last release
          if [ -z "$RELEASE_TAG" ]; then
            # No previous release, get all commits
            COMMITS=$(git log --pretty=format:"%s" --reverse)
            echo "No previous release, analyzing all commits"
          else
            # Get commits since last release tag
            COMMITS=$(git log $RELEASE_TAG..HEAD --pretty=format:"%s" --reverse || git log --pretty=format:"%s" --reverse)
            echo "Analyzing commits since $RELEASE_TAG"
          fi

          # Analyze commits for version bump type
          HAS_MAJOR=false
          HAS_MINOR=false
          HAS_FIX=false
          HAS_CHORE=false
          CHANGELOG=""

          while IFS= read -r commit_msg; do
            if [ -z "$commit_msg" ]; then
              continue
            fi

            # Add to changelog
            CHANGELOG="${CHANGELOG}- ${commit_msg}\n"

            # Check commit prefix
            if echo "$commit_msg" | grep -qE "^major:"; then
              HAS_MAJOR=true
            elif echo "$commit_msg" | grep -qE "^minor:"; then
              HAS_MINOR=true
            elif echo "$commit_msg" | grep -qE "^fix:"; then
              HAS_FIX=true
            elif echo "$commit_msg" | grep -qE "^chore:"; then
              HAS_CHORE=true
            fi
          done <<< "$COMMITS"

          # Calculate new version based on commit types
          NEW_MAJOR=$MAJOR
          NEW_MINOR=$MINOR
          NEW_PATCH=$PATCH
          IS_ROLLBACK=false
          ROLLBACK_HASH=""

          # Check if only chore commits exist
          if [ "$HAS_CHORE" = true ] && [ "$HAS_MAJOR" = false ] && [ "$HAS_MINOR" = false ] && [ "$HAS_FIX" = false ]; then
            # Only chore commits - create rollback release with hash
            IS_ROLLBACK=true
            ROLLBACK_HASH=$(date +%s | sha256sum | head -c 8)
            NEW_VERSION="$CURRENT_VERSION"
            echo "Only chore commits detected, creating rollback release with hash: $ROLLBACK_HASH"
          elif [ "$HAS_MAJOR" = true ]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          elif [ "$HAS_MINOR" = true ]; then
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          elif [ "$HAS_FIX" = true ]; then
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          else
            # No relevant commits found, keep current version
            NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          fi

          echo "Service: $SERVICE_NAME"
          echo "Current version: $CURRENT_VERSION"
          echo "New version: $NEW_VERSION"
          echo "Is rollback: $IS_ROLLBACK"
          echo "Rollback hash: $ROLLBACK_HASH"
          echo "Has major: $HAS_MAJOR"
          echo "Has minor: $HAS_MINOR"
          echo "Has fix: $HAS_FIX"
          echo "Has chore: $HAS_CHORE"

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "is_rollback=$IS_ROLLBACK" >> $GITHUB_OUTPUT
          echo "rollback_hash=$ROLLBACK_HASH" >> $GITHUB_OUTPUT
          echo "$NEW_VERSION" > new_version_$SERVICE_NAME.txt
          echo "$IS_ROLLBACK" > is_rollback_$SERVICE_NAME.txt
          echo "$ROLLBACK_HASH" > rollback_hash_$SERVICE_NAME.txt
          echo -e "$CHANGELOG" > changelog_$SERVICE_NAME.txt
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload new version, rollback info and changelog
        uses: actions/upload-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
          path: |
            new_version_${{ matrix.service-name }}.txt
            is_rollback_${{ matrix.service-name }}.txt
            rollback_hash_${{ matrix.service-name }}.txt
            changelog_${{ matrix.service-name }}.txt

  security-checks:
    name: Security checks for all services
    needs: [prepare-services]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Security scan check for NestJS ${{ matrix.service-name }}
        if: needs.prepare-services.outputs.service-type == 'nest'
        uses: ./.github/workflows/jobs/nest-application-security-check
        with:
          service-name: ${{ matrix.service-name }}
      - name: Security scan check for Next.js ${{ matrix.service-name }}
        if: needs.prepare-services.outputs.service-type == 'next'
        uses: ./.github/workflows/jobs/next-application-security-check
        with:
          service-name: ${{ matrix.service-name }}

  build-image-to-docker-hub:
    # TODO: fix secrets
    name: Build and push image to Docker Hub for ${{ matrix.service-name }}
    needs: [prepare-services, security-checks, calculate-new-version]
    runs-on: ubuntu-latest
    continue-on-error: true
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
      - name: Get version for service
        id: get-version
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          VERSION_FILE="new_version_$SERVICE_NAME.txt"

          # Check if version file exists and is not empty
          if [ ! -f "$VERSION_FILE" ]; then
            echo "Error: Version file $VERSION_FILE not found"
            exit 1
          fi

          VERSION=$(cat "$VERSION_FILE" | tr -d '[:space:]')

          # Validate version is not empty
          if [ -z "$VERSION" ]; then
            echo "Error: Version is empty in $VERSION_FILE"
            exit 1
          fi

          # Validate version format (should be x.y.z)
          if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Error: Invalid version format: $VERSION (expected x.y.z)"
            exit 1
          fi

          echo "Building $SERVICE_NAME with version $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./services/${{ matrix.service-name }}/Dockerfile
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/supreme:production-${{ matrix.service-name }}-v${{ steps.get-version.outputs.version }}
          cache-to: type=inline

  create-release-branch:
    name: Create release branch for ${{ matrix.service-name }}
    needs: [prepare-services, calculate-new-version]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
      - name: Configure Git
        run: |
          git config --global user.email "246592117+madara-robot@users.noreply.github.com"
          git config --global user.name "madara-robot"
      - name: Get version and create branch
        id: create-branch
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          VERSION=$(cat new_version_$SERVICE_NAME.txt)
          BRANCH_NAME="releases/production/${SERVICE_NAME}-${VERSION}"

          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists"
            git checkout "$BRANCH_NAME"
          else
            # Create and push new branch from current HEAD
            git checkout -b "$BRANCH_NAME"
            git push -u origin "$BRANCH_NAME"
            echo "Created branch $BRANCH_NAME"
          fi

          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create-github-release:
    name: Create GitHub release for ${{ matrix.service-name }}
    needs: [prepare-services, build-image-to-docker-hub, calculate-new-version, create-release-branch]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Download new version and changelog files
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
      - name: Get version, rollback info and prepare changelog
        id: get-release-info
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          VERSION=$(cat new_version_$SERVICE_NAME.txt)
          IS_ROLLBACK=$(cat is_rollback_$SERVICE_NAME.txt 2>/dev/null || echo "false")
          ROLLBACK_HASH=$(cat rollback_hash_$SERVICE_NAME.txt 2>/dev/null || echo "")
          CHANGELOG=$(cat changelog_$SERVICE_NAME.txt 2>/dev/null || echo "")

          # Determine tag name and release name
          if [ "$IS_ROLLBACK" = "true" ] && [ -n "$ROLLBACK_HASH" ]; then
            TAG_NAME="${SERVICE_NAME}-v${VERSION}-${ROLLBACK_HASH}"
            RELEASE_NAME="Rollback ${SERVICE_NAME} v${VERSION}"
          else
            TAG_NAME="${SERVICE_NAME}-v${VERSION}"
            RELEASE_NAME="Release ${SERVICE_NAME} v${VERSION}"
          fi

          echo "Creating release for $SERVICE_NAME"
          echo "Tag: $TAG_NAME"
          echo "Release name: $RELEASE_NAME"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT

          # Count changelog lines
          if [ -n "$CHANGELOG" ]; then
            CHANGELOG_LINES=$(echo "$CHANGELOG" | wc -l)
          else
            CHANGELOG_LINES=0
          fi

          # Prepare release body
          {
            echo "$RELEASE_NAME"
            echo ""
            echo "## Changelog"
            if [ -n "$CHANGELOG" ]; then
              if [ "$CHANGELOG_LINES" -gt 12 ]; then
                # Hide long changelog in collapsible section
                echo "<details>"
                echo ""
                echo "<summary>"
                echo ""
                echo "view full changelog"
                echo ""
                echo "</summary>"
                echo ""
                echo "<pre>"
                echo "$CHANGELOG"
                echo "</pre>"
                echo ""
                echo "</details>"
              else
                # Show short changelog directly
                echo "$CHANGELOG"
              fi
            else
              echo "No changes"
            fi
            echo ""
            echo "## Docker Image"
            echo "https://hub.docker.com/repository/docker/sewaca/supreme/general\n"
            echo "\`${{ secrets.DOCKER_HUB_USERNAME }}/supreme:production-${{ matrix.service-name }}-v${{ $VERSION }}\`"
          } > release_body_$SERVICE_NAME.txt

          echo "Release body prepared"
      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y
      - name: Create GitHub Release
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          TAG_NAME="${{ steps.get-release-info.outputs.tag_name }}"
          RELEASE_NAME="${{ steps.get-release-info.outputs.release_name }}"
          BODY_FILE="release_body_${SERVICE_NAME}.txt"

          # Check if release already exists
          if gh release view "$TAG_NAME" --repo ${{ github.repository }} >/dev/null 2>&1; then
            echo "Release $TAG_NAME already exists, skipping creation"
            exit 0
          fi

          # Check if tag exists but release doesn't
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME exists but release doesn't, creating release from existing tag"
            gh release create "$TAG_NAME" \
              --title "$RELEASE_NAME" \
              --notes-file "$BODY_FILE" \
              --repo ${{ github.repository }} \
              --verify-tag
          else
            echo "Creating new release $TAG_NAME"
            gh release create "$TAG_NAME" \
              --title "$RELEASE_NAME" \
              --notes-file "$BODY_FILE" \
              --repo ${{ github.repository }}
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-to-yandex-cloud:
    name: Deploy to Yandex Cloud for ${{ matrix.service-name }}
    needs: [prepare-services, build-image-to-docker-hub, create-github-release]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Deploy to Yandex Cloud
        run: |
          echo "Deploying ${{ matrix.service-name }} to Yandex Cloud"
          # TODO: Implement actual deployment logic
        env:
          YC_TOKEN: ${{ secrets.YC_TOKEN }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}

# TODO:
# Примечание: Для работы потребуются secrets в GitHub:
# DOCKER_HUB_USERNAME и DOCKER_HUB_TOKEN для публикации образов
# YC_TOKEN и YC_FOLDER_ID для деплоя в Yandex Cloud
