name: CD Pipeline

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Select service to deploy'
        required: true
        type: choice
        options:
          - backend
          - frontend
        default: 'backend'

jobs:
  prepare-services:
    name: Prepare services list
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set-services.outputs.services }}
    steps:
      - name: Set services list
        id: set-services
        run: |
          # Get selected service
          SELECTED_SERVICE="${{ github.event.inputs.service }}"
          
          # Convert to JSON array (single service wrapped in array)
          # Install jq if not available
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
          SERVICES_JSON=$(echo "$SELECTED_SERVICE" | jq -R -c '[.]')

          echo "Selected service: $SELECTED_SERVICE"
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Services JSON: $SERVICES_JSON"

  get-latest-release-version:
    name: Get latest release version for ${{ matrix.service-name }}
    needs: prepare-services
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || (apt update && apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && apt update \
          && apt install gh -y
      - name: Get latest release version
        id: get-version
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          LATEST_RELEASE=$(gh release list --repo ${{ github.repository }} --limit 100 | grep "^$SERVICE_NAME-v" | head -n 1 | awk '{print $1}' || echo "")

          if [ -z "$LATEST_RELEASE" ]; then
            VERSION="0.0.0"
            echo "No previous release found for $SERVICE_NAME, using version: $VERSION"
          else
            VERSION=$(echo "$LATEST_RELEASE" | sed "s/^$SERVICE_NAME-v//")
            echo "Latest release for $SERVICE_NAME: $LATEST_RELEASE, version: $VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "service=$SERVICE_NAME" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Save version to file
        run: |
          echo "${{ steps.get-version.outputs.version }}" > version_${{ matrix.service-name }}.txt
      - name: Upload version file
        uses: actions/upload-artifact@v4
        with:
          name: version-${{ matrix.service-name }}
          path: version_${{ matrix.service-name }}.txt

  calculate-new-version:
    name: Calculate new version for ${{ matrix.service-name }}
    needs: [prepare-services, get-latest-release-version]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Download version file
        uses: actions/download-artifact@v4
        with:
          name: version-${{ matrix.service-name }}
      - name: Calculate new version
        id: calculate-version
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          CURRENT_VERSION=$(cat version_$SERVICE_NAME.txt)

          # Parse version (assuming semantic versioning)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"

          echo "Service: $SERVICE_NAME"
          echo "Current version: $CURRENT_VERSION"
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "$NEW_VERSION" > new_version_$SERVICE_NAME.txt
      - name: Upload new version file
        uses: actions/upload-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
          path: new_version_${{ matrix.service-name }}.txt

  security-checks:
    name: Security checks for all services
    needs: [prepare-services]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Security scan check for NestJS ${{ matrix.service-name }}
        if: matrix.service-name == 'backend'
        uses: ./.github/workflows/jobs/nest-application-security-check
        with:
          service-name: ${{ matrix.service-name }}
      - name: Security scan check for Next.js ${{ matrix.service-name }}
        if: matrix.service-name == 'frontend'
        uses: ./.github/workflows/jobs/next-application-security-check
        with:
          service-name: ${{ matrix.service-name }}

  build-image-to-docker-hub:
    name: Build and push image to Docker Hub for ${{ matrix.service-name }}
    needs: [prepare-services, security-checks, calculate-new-version]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
      - name: Get version for service
        id: get-version
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          VERSION=$(cat new_version_$SERVICE_NAME.txt)
          echo "Building $SERVICE_NAME with version $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./services/${{ matrix.service-name }}
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/supreme-${{ matrix.service-name }}:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/supreme-${{ matrix.service-name }}:${{ steps.get-version.outputs.version }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME }}/supreme-${{ matrix.service-name }}:latest
          cache-to: type=inline

  create-github-release:
    name: Create GitHub release for ${{ matrix.service-name }}
    needs: [prepare-services, build-image-to-docker-hub, calculate-new-version]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Download new version file
        uses: actions/download-artifact@v4
        with:
          name: new-version-${{ matrix.service-name }}
      - name: Get version for service
        id: get-version
        run: |
          SERVICE_NAME="${{ matrix.service-name }}"
          VERSION=$(cat new_version_$SERVICE_NAME.txt)
          echo "Creating release for $SERVICE_NAME with version $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: Create GitHub Release
        uses: ncipollo/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag: ${{ matrix.service-name }}-v${{ steps.get-version.outputs.version }}
          name: Release ${{ matrix.service-name }} v${{ steps.get-version.outputs.version }}
          body: |
            Release ${{ matrix.service-name }} v${{ steps.get-version.outputs.version }}

            Docker image: ${{ secrets.DOCKER_HUB_USERNAME }}/supreme-${{ matrix.service-name }}:${{ steps.get-version.outputs.version }}
          draft: false
          prerelease: false

  deploy-to-yandex-cloud:
    name: Deploy to Yandex Cloud for ${{ matrix.service-name }}
    needs: [prepare-services, build-image-to-docker-hub, create-github-release]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service-name: ${{ fromJSON(needs.prepare-services.outputs.services) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Deploy to Yandex Cloud
        run: |
          echo "Deploying ${{ matrix.service-name }} to Yandex Cloud"
          # TODO: Implement actual deployment logic
        env:
          YC_TOKEN: ${{ secrets.YC_TOKEN }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}

# # Примечание: Для работы потребуются secrets в GitHub:
# DOCKER_HUB_USERNAME и DOCKER_HUB_TOKEN для публикации образов
# YC_TOKEN и YC_FOLDER_ID для деплоя в Yandex Cloud
