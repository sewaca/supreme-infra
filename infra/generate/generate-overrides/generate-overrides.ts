import * as fs from 'node:fs';
import * as path from 'node:path';
import * as yaml from 'yaml';
import { getServiceByName, loadServices } from '../shared/load-services';
import type { ServiceConfig } from './types';

const HELM_CHART_MAPPING: Record<string, string> = {
  nest: 'backend-service',
  next: 'frontend-service',
};

const ENVIRONMENTS = ['development', 'production'];

function log(message: string, level: 'info' | 'success' | 'error' | 'debug' = 'info'): void {
  const prefix = {
    info: '→',
    success: '✓',
    error: '✗',
    debug: '  •',
  };
  console.log(`${prefix[level]} ${message}`);
}

/**
 * Глубокое слияние двух объектов.
 * Значения из source перезаписывают значения из target.
 */
function deepMerge<T>(target: T, source: Partial<T>): T {
  const result = { ...target } as T;

  for (const key in source) {
    const sourceValue = source[key];
    const targetValue = result[key];

    if (sourceValue === undefined) continue;

    const isSourceObject = typeof sourceValue === 'object' && sourceValue !== null && !Array.isArray(sourceValue);
    const isTargetObject = typeof targetValue === 'object' && targetValue !== null && !Array.isArray(targetValue);

    if (isSourceObject && isTargetObject) {
      result[key] = deepMerge(targetValue, sourceValue) as T[Extract<keyof T, string>];
    } else {
      result[key] = sourceValue as T[Extract<keyof T, string>];
    }
  }

  return result;
}

function getHelmChartPath(serviceType: 'nest' | 'next'): string {
  const chartName = HELM_CHART_MAPPING[serviceType];
  return path.join(__dirname, '../../helmcharts', chartName);
}

function loadHelmDefaults(serviceType: 'nest' | 'next'): ServiceConfig {
  const helmChartPath = getHelmChartPath(serviceType);
  const valuesPath = path.join(helmChartPath, 'values.yaml');
  const content = fs.readFileSync(valuesPath, 'utf-8');
  return yaml.parse(content) as ServiceConfig;
}

function loadServiceConfig(serviceName: string): ServiceConfig {
  const serviceYamlPath = path.join(__dirname, '../../../services', serviceName, 'service.yaml');

  if (!fs.existsSync(serviceYamlPath)) {
    throw new Error(`Service config not found: ${serviceYamlPath}`);
  }

  const content = fs.readFileSync(serviceYamlPath, 'utf-8');
  return yaml.parse(content) as ServiceConfig;
}

/**
 * Генерирует финальные values для сервиса в указанном окружении.
 *
 * Порядок применения (от низшего приоритета к высшему):
 * 1. values.yaml — базовые дефолты из helm chart
 * 2. service.yaml (без overrides) — общий конфиг сервиса
 * 3. service.yaml.overrides[env] — специфичные переопределения для окружения
 */
function generateValuesForService(serviceName: string, environment: string): ServiceConfig {
  const serviceInfo = getServiceByName(serviceName);
  if (!serviceInfo) {
    throw new Error(`Service ${serviceName} not found in services.yaml`);
  }

  // 1. Загружаем базовые дефолты из helm chart
  const helmDefaults = loadHelmDefaults(serviceInfo.type);

  // 2. Загружаем конфиг сервиса и отделяем overrides
  const serviceConfig = loadServiceConfig(serviceName);
  const { overrides: serviceOverrides, ...serviceBaseConfig } = serviceConfig;

  // 3. Получаем переопределения для конкретного окружения
  const envOverrides = serviceOverrides?.[environment] ?? {};

  // Применяем в правильном порядке
  let values: ServiceConfig = { ...helmDefaults };
  values = deepMerge(values, serviceBaseConfig);
  values = deepMerge(values, envOverrides);

  // Устанавливаем NODE_ENV
  values.env = {
    ...values.env,
    NODE_ENV: environment === 'development' ? 'development' : 'production',
  };

  return values;
}

function ensureDirectoryExists(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

function generateFileHeader(serviceName: string, environment: string): string {
  return [
    `# This file is automatically generated and should not be edited manually!`,
    `# Generated values for ${serviceName} in ${environment} environment`,
    `# Source: services/${serviceName}/service.yaml`,
    '',
  ].join('\n');
}

function writeValuesFile(serviceName: string, environment: string, values: ServiceConfig): void {
  const overridesDir = path.join(__dirname, '../../overrides', environment);
  ensureDirectoryExists(overridesDir);

  const outputPath = path.join(overridesDir, `${serviceName}.yaml`);
  const header = generateFileHeader(serviceName, environment);
  const yamlContent = yaml.stringify(values, { indent: 2 });
  const output = header + yamlContent;

  fs.writeFileSync(outputPath, output, 'utf-8');

  const relativePath = path.relative(process.cwd(), outputPath);
  log(`Generated: ${relativePath}`, 'success');
}

export function generateValuesForAllServices(): void {
  log('Starting values generation process', 'info');

  const services = loadServices();
  const nestServices = services.nest || [];
  const nextServices = services.next || [];
  const allServices = [...nestServices, ...nextServices];

  log(`Found ${allServices.length} service(s) to process:`, 'info');
  for (const service of nestServices) {
    log(`  • ${service.name} (nest)${service.description ? ` - ${service.description}` : ''}`, 'info');
  }
  for (const service of nextServices) {
    log(`  • ${service.name} (next)${service.description ? ` - ${service.description}` : ''}`, 'info');
  }

  let successCount = 0;
  let errorCount = 0;

  for (const service of allServices) {
    log(`Processing service: ${service.name}`, 'info');

    for (const environment of ENVIRONMENTS) {
      try {
        const values = generateValuesForService(service.name, environment);
        writeValuesFile(service.name, environment, values);
        successCount++;
      } catch (error) {
        log(
          `Error generating values for ${service.name} in ${environment}: ${error instanceof Error ? error.message : error}`,
          'error',
        );
        errorCount++;
      }
    }
  }

  log('Generation summary:', 'info');
  log(`  Total files generated: ${successCount}`, 'success');
  if (errorCount > 0) {
    log(`  Errors encountered: ${errorCount}`, 'error');
  }
}
